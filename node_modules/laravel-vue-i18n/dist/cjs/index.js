"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.i18nVue = exports.trans_choice = exports.reset = exports.getActiveLanguage = exports.wTransChoice = exports.transChoice = exports.wTrans = exports.trans = exports.loadLanguageAsync = exports.isLoaded = void 0;
const vue_1 = require("vue");
const pluralization_1 = require("./pluralization");
const avoid_exceptions_1 = require("./utils/avoid-exceptions");
const has_php_translations_1 = require("./utils/has-php-translations");
const isServer = typeof window === 'undefined';
/**
 * The default options, for the plugin.
 */
const DEFAULT_OPTIONS = {
    lang: !isServer && document.documentElement.lang ? document.documentElement.lang.replace('-', '_') : null,
    fallbackLang: 'en',
    resolve: (lang) => new Promise((resolve) => resolve({ default: {} }))
};
/**
 * Stores the current options.
 */
let options = DEFAULT_OPTIONS;
/**
 * Stores the loaded languages.
 */
let loaded = [];
/**
 * The active messages to use.
 */
const activeMessages = (0, vue_1.reactive)({});
/**
 * Checks if the language is loaded.
 */
function isLoaded(lang) {
    lang !== null && lang !== void 0 ? lang : (lang = getActiveLanguage());
    return loaded.some((row) => row.lang.replace(/[-_]/g, '-') === lang.replace(/[-_]/g, '-'));
}
exports.isLoaded = isLoaded;
/**
 * Loads the language async.
 */
function loadLanguage(lang, dashLangTry = false) {
    const loadedLang = loaded.find((row) => row.lang === lang);
    if (loadedLang) {
        setLanguage(loadedLang);
        return;
    }
    const { default: messages } = resolveLang(options.resolve, lang);
    applyLanguage(lang, messages, dashLangTry, loadLanguage);
}
/**
 * Loads the language file.
 */
function loadLanguageAsync(lang, dashLangTry = false) {
    const loadedLang = loaded.find((row) => row.lang === lang);
    if (loadedLang) {
        return Promise.resolve(setLanguage(loadedLang));
    }
    return resolveLangAsync(options.resolve, lang).then(({ default: messages }) => applyLanguage(lang, messages, dashLangTry, loadLanguageAsync));
}
exports.loadLanguageAsync = loadLanguageAsync;
/**
 * Applies the language data and saves it to the loaded storage.
 */
function applyLanguage(lang, messages, dashLangTry = false, callable) {
    if (Object.keys(messages).length < 1) {
        if (/[-_]/g.test(lang) && !dashLangTry) {
            return callable(lang.replace(/[-_]/g, (char) => (char === '-' ? '_' : '-')), true);
        }
        if (lang !== options.fallbackLang) {
            return callable(options.fallbackLang);
        }
    }
    const data = { lang, messages };
    loaded.push(data);
    return setLanguage(data);
}
/**
 * Get the translation for the given key.
 */
function trans(key, replacements = {}) {
    return wTrans(key, replacements).value;
}
exports.trans = trans;
/**
 * Get the translation for the given key and watch for any changes.
 */
function wTrans(key, replacements = {}) {
    if (!activeMessages[key]) {
        activeMessages[key] = key;
    }
    return (0, vue_1.computed)(() => makeReplacements(activeMessages[key], replacements));
}
exports.wTrans = wTrans;
/**
 * Translates the given message based on a count.
 */
function transChoice(key, number, replacements = {}) {
    return wTransChoice(key, number, replacements).value;
}
exports.transChoice = transChoice;
/**
 * Translates the given message based on a count and watch for changes.
 */
function wTransChoice(key, number, replacements = {}) {
    const message = wTrans(key, replacements);
    replacements.count = number.toString();
    return (0, vue_1.computed)(() => makeReplacements((0, pluralization_1.choose)(message.value, number, options.lang), replacements));
}
exports.wTransChoice = wTransChoice;
/**
 * Returns the current active language.
 */
function getActiveLanguage() {
    return options.lang || options.fallbackLang;
}
exports.getActiveLanguage = getActiveLanguage;
/**
 * Sets the language messages to the activeMessages.
 */
function setLanguage({ lang, messages }) {
    if (!isServer) {
        // When setting the HTML lang attribute, hyphen must be use instead of underscore.
        document.documentElement.setAttribute('lang', lang.replace('_', '-'));
    }
    options.lang = lang;
    for (const [key, value] of Object.entries(messages)) {
        activeMessages[key] = value;
    }
    for (const [key] of Object.entries(activeMessages)) {
        if (!messages[key]) {
            activeMessages[key] = null;
        }
    }
    return lang;
}
/**
 * It resolves the language file or data, from direct data, syncrone.
 */
function resolveLang(callable, lang, data = {}) {
    if (!Object.keys(data).length) {
        data = (0, avoid_exceptions_1.avoidException)(callable, lang);
    }
    if ((0, has_php_translations_1.hasPhpTranslations)(isServer)) {
        return {
            default: Object.assign(Object.assign({}, data), (0, avoid_exceptions_1.avoidException)(callable, `php_${lang}`))
        };
    }
    return { default: data };
}
/**
 * It resolves the language file or data, from direct data, require or Promise.
 */
function resolveLangAsync(callable, lang) {
    return __awaiter(this, void 0, void 0, function* () {
        let data = (0, avoid_exceptions_1.avoidException)(callable, lang);
        if (!(data instanceof Promise)) {
            return resolveLang(callable, lang, data);
        }
        if ((0, has_php_translations_1.hasPhpTranslations)(isServer)) {
            const phpLang = yield (0, avoid_exceptions_1.avoidExceptionOnPromise)(callable(`php_${lang}`));
            const jsonLang = yield (0, avoid_exceptions_1.avoidExceptionOnPromise)(data);
            return new Promise((resolve) => resolve({
                default: Object.assign(Object.assign({}, phpLang), jsonLang)
            }));
        }
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            return resolve({
                default: yield (0, avoid_exceptions_1.avoidExceptionOnPromise)(data)
            });
        }));
    });
}
/**
 * Make the place-holder replacements on a line.
 */
function makeReplacements(message, replacements) {
    const capitalize = (s) => s.charAt(0).toUpperCase() + s.slice(1);
    Object.entries(replacements || []).forEach(([key, value]) => {
        value = value.toString();
        message = message
            .replace(`:${key}`, value)
            .replace(`:${key.toUpperCase()}`, value.toUpperCase())
            .replace(`:${capitalize(key)}`, capitalize(value));
    });
    return message;
}
/**
 * Resets all the data stored in memory.
 */
const reset = () => {
    loaded = [];
    options = DEFAULT_OPTIONS;
    for (const [key] of Object.entries(activeMessages)) {
        activeMessages[key] = null;
    }
};
exports.reset = reset;
/**
 * Alias to `transChoice` to mimic the same function name from Laravel Framework.
 */
exports.trans_choice = transChoice;
/**
 * The Vue Plugin. to be used on your Vue app like this: `app.use(i18nVue)`
 */
exports.i18nVue = {
    install: (app, currentOptions = {}) => {
        options = Object.assign(Object.assign({}, options), currentOptions);
        app.config.globalProperties.$t = (key, replacements) => trans(key, replacements);
        app.config.globalProperties.$tChoice = (key, number, replacements) => transChoice(key, number, replacements);
        if (isServer) {
            loadLanguage(options.lang || options.fallbackLang);
        }
        else {
            loadLanguageAsync(options.lang || options.fallbackLang);
        }
    }
};
