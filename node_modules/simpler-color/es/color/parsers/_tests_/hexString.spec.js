import { isHexString, matchHexString } from '../hexString';
describe('isHexString', () => {
  const valid = ['#33FFAA', '#ff33aa', '#FFaa33', '#33FFAABB', '#33ffaabb', '#3FA', '#3fab'];
  valid.forEach(str => {
    it(`returns true for valid hex string: ${str}`, () => {
      expect(isHexString(str)).toBe(true);
    });
  });
  const invalid = ['rgb(127, 255, 255)', 'blue', 'BBAADD', ' #BBAADD ', '#BB AA DD', 'rainbow'];
  invalid.forEach(str => {
    it(`returns false for invalid hex string: ${str}`, () => {
      expect(isHexString(str)).toBe(false);
    });
  });
});
describe('matchHexString', () => {
  it('returns the RGB and alpha (opacity) hex values in an array', () => {
    const str = '#FFAACCEE';
    expect(matchHexString(str)).toEqual(['FF', 'AA', 'CC', 'EE']);
  });
  it('returns only a 3-item array if color has no alpha value', () => {
    const str = '#ffaabb';
    expect(matchHexString(str)).toEqual(['ff', 'aa', 'bb']);
  });
  it('captures shorthand RGB and alpha hex values', () => {
    const str = '#FACE';
    expect(matchHexString(str)).toEqual(['F', 'A', 'C', 'E']);
  });
  it('returns null if string is not a valid hex string', () => {
    const str = 'rgb(127, 255, 64)';
    expect(matchHexString(str)).toBeNull();
  });
});